---
title: Human gene expression
---

```{r expression_setup, echo=FALSE, warning=FALSE, message=FALSE, cache=FALSE}
knitr::read_chunk("settings.R")
```

```{r rendering_settings, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE}
```

```{r io_settings, echo = FALSE, warning=FALSE, message=FALSE, cache=FALSE}
```

## Installation

```{r eval = FALSE}
source("https://bioconductor.org/biocLite.R")
source("http://bioconductor.org/workflows.R")
```

```{r eval = FALSE}
workflowInstall("rnaseqGene")
biocLite("GO.db")
biocLite("org.Hs.eg.db")
biocLite("airway")
biocLite("DESeq2")
```



## Read in data

### Starting from SummarizedExperiment

```{r}
library(rnaseqGene)
library("airway")
data("airway")
se <- airway
```

```{r}
se$dex <- relevel(se$dex, "untrt")
se$dex
```

```{r}
library("DESeq2")
dds <- DESeqDataSet(se, design = ~ cell + dex)
```

### Pre-filtering the dataset

```{r}
nrow(dds)
dds <- dds[ rowSums(counts(dds)) > 1, ]
nrow(dds)
```

### The rlog transformation

```{r}
rld <- rlog(dds, blind=FALSE)
head(assay(rld), 3)
```


```{r}
par( mfrow = c( 1, 2 ) )
dds <- estimateSizeFactors(dds)
plot(log2(counts(dds, normalized=TRUE)[,1:2] + 1),
     pch=16, cex=0.3)
plot(assay(rld)[,1:2],
     pch=16, cex=0.3)
```


### Differential expression analysis

```{r}
dds <- DESeq(dds)
(res <- results(dds))
```




### Converting ENSEMBL IDs to GO IDs


```{r}
library(GO.db)
library(org.Hs.eg.db)
res$go_id <- mapIds(org.Hs.eg.db,
                    keys=rownames(res),
                    column="GO",
                    keytype="ENSEMBL",
                    multiVals="first")
```


### Fitlering results 

Remove genes with no GO annotation 

```{r}
res <- res[!is.na(res$go_id), ]
res <- res[res$go_id %in% keys(org.Hs.eg.db, keytype = "GO"), ]
```

Remove insignificant genes

```{r}
res <- res[(! is.na(res$padj)) & res$padj <= 0.05, ]
```

Remove genes with small changes

```{r}
res <-  res[abs(res$log2FoldChange) >= 0.5, ]
```


### Getting classificaiton

```{r}
valid_go <- names(as.list(GOBPPARENTS))
term_class <- function(x, current = x, all_paths = TRUE) {
  # Get immediate children of current taxon
  parents = tryCatch({
    names(AnnotationDbi::Term(as.list(GOBPPARENTS[x[1]])[[1]]))
  }, error = function(e) {
    c()
  })
  
  # only go down one path if desired
  if (! all_paths) {
    parents <- parents[1]
  }
  parents <- parents[parents != "all"]
  
  if (length(parents) == 0) {
    return(paste0(collapse = "|", AnnotationDbi::Term(x)))
  } else {
    next_x <- lapply(parents, function(y) c(y, x))
    
    # Run this function on them to get their output
    child_output <- lapply(next_x, term_class, all_paths = all_paths)
    output <- unlist(child_output, recursive = FALSE)
    
    return(output)
  }
}

```



```{r}
classifications <- lapply(res$go_id, term_class, all_paths = FALSE)
res <- res[rep(1:nrow(res), sapply(classifications, length)), ]
res$class <- unlist(classifications)
```


### Parse into taxmap

```{r}
library(metacoder)
data <- parse_taxonomy_table(input = as.data.frame(res), taxon_col = c("class" = -1), other_col_type = "obs_info", class_sep = "\\|")
```


```{r}
data$taxon_funcs <- c(data$taxon_funcs,
                      change = function(x, subset = NULL) {
                        vapply(obs(x),
                               function(i) mean(data$obs_data[i, ]$log2FoldChange, na.rm = TRUE),
                               numeric(1))
                      })
```


### Graph

```{r}
data %>%
  # filter_taxa(name == "molecular_function", subtaxa = TRUE) %>%
  # filter_taxa(abs(change) > 0.5, supertaxa = TRUE) %>%
  heat_tree(node_label = name,
            node_size = n_obs,
            node_color = change,
            node_color_trans = "linear",
            node_color_range = diverging_palette(),
            node_color_interval = c(-1, 1),
            edge_color_trans = "linear",
            edge_color_range = diverging_palette(),
            edge_color_interval = c(-1, 1),
            node_label_max = 300)
```


